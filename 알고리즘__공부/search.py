# 탐색
# 순차탐색: 리스트 안에있는 원소들을 순차적으로 비교한다

# 정렬
# 선택정렬: 남은 자료 중에 최솟값을 찾아 차례로 배치

def sel_sort(a):
    n = len(a)

    for i in range(0, n - 1):  # 0부터 n -2까지 반복(n은 리스트의 개수니까)
        # i번 위치부터 끝까지 자료 값 중 최솟값의 위치를 찾음
        min_idx = i
        for j in range(i + 1, n):
            if a[j] < a[min_idx]:  # 뒤의 j인덱스의 값이 최솟값 인덱스보다 작다면
                min_idx = j  # 두 개를 swap
        # 찾은 최솟값을 i번 위치로
        a[i], a[min_idx] = a[min_idx], a[i]


d = [2, 4, 5, 1, 3]
sel_sort(d)
print(d)

# -----------------------------------------------------------
# 삽입정렬: 아무 요소나 뽑아서 줄을 세우고 적절한 위치에 삽입한다
# 입력: 리스트 a
# 출력: 없음(입력으로 주어진 a가 정렬됨)


def ins_sort(a):
    n = len(a)
    for i in range(1, n):  # 1부터 n -1까지
        key = a[i]  # i번 위치에 있는 값을 key에 저장
        # j를 i 바로 왼쪽 위치로 저장
        j = i - 1
        # 리스트의 j번 위치에 있는 값과 key를 비교해 key가 삽입될 적절한 위치를 찾음
        while j >= 0 and a[j] > key:
            a[j + 1] = a[j]  # 삽입할 공간이 생기도록 값을 오른쪽으로 한 칸 이동
            j -= 1
        a[j + 1] = key  # 찾은 삽입 위치에 key를 저장


d = [2, 4, 5, 1, 3]
ins_sort(d)
print(d)


# 병합정렬: 두 개의 그룹으로 나눠서 재귀함수 호출로 각각 정렬한 후에 그룹을 병합

# log와 지수에 대한 이해:
# 2^10 = 1024, log2에1024 = 10, 2^5=32 log2에32는 5

# 퀵 정렬: 기준을 통해서 두 그룹으로 나누고 재귀함수 호출해서 정렬
# 거품정렬: 앞에서부터 두개씩 비교해서 정렬함
