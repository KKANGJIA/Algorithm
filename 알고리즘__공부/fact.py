def fact(a):
    result = 1
    for i in range(1, a+1):
        result *= i
    return result


print(fact(10))

# --------------------------------------------------------------------

'''
재귀호출(recursion): 어떤 함수 안에서 자기 자신을 부르는 말
def hello():
    print('Hello!')
    hello() # hello() 함수 안에서 다시 hello()를 부름

hello()

하지만 위의 재귀함수는 계속 호출이 되어서 종료되는 부분이 없다(recursion error 발생)
올바른 재귀함수를 작성하려면 종료를 할 수 있는 부분을 넣어야 한다
'''

# --------------------------------------------------------------------

# 연속한 숫자를 곱하는 팩토리얼★
# 입력:n
# 출력: 1부터 n까지 곱한 값


def fact(n):
    if n <= 1:
        return 1
    return n * fact(n-1)


print(fact(10))

'''
재귀함수의 계산 절차
n = 4

4*fact(3)
fact(3) -> 3*fact(2)
fact(2) -> 2*fact(1)

4*3*2*1 = 24(최종결과)


재귀함수의 계산 복잡도는 O(n)
'''
# --------------------------------------------------------------------

'''
재귀함수의 일반적인 형태
def func(입력값):
    if 입력값이 충분히 작으면: # 종료조건이 필요
        return 결괏값 
    
    func(더 작은 입력값) # 더 작은 값으로 자기 자신을 호출

    return 결괏값
'''

# --------------------------------------------------------------------

# 4-1 재귀 호출을 이용해 1부터 n까지의 합 구하기

# 종료 조건: n = 0 → 결괏값 0
# 재귀 호출 조건: n까지의 합 = n - 1까지의 합 + n

# 연속한 숫자의 합을 구하는 알고리즘
# 입력: n
# 출력: 1부터 n까지 연속한 숫자를 더한 값


def sum_n(n):
    if n == 0:
        return 0
    return sum_n(n - 1) + n


print(sum_n(10))  # 1부터 10까지의 합(입력: 10, 출력: 55)
print(sum_n(100))  # 1부터 100까지의 합(입력: 100, 출력: 5050)

# --------------------------------------------------------------------

# 4-2 재귀 호출을 이용한 최댓값 찾기(★★재귀함수 눈여겨 보기★★)

# • 종료 조건: 자료 값이 한 개면(n = 1) 그 값이 최댓값
# • 재귀 호출 조건: n개 자료 중 최댓값 → n-1개 자료 중 최댓값과 n-1번 위치 값 중 더 큰 값


def find_max(a, n):  # 리스트 매개변수 a, 개수 매개변수 n
    if n == 1:  # 길이가 1이면
        return a[0]  # 그 값을 최댓값으로 반환
    max_n_1 = find_max(a, n - 1)  # n - 1개 중 최댓값을 구함
    if max_n_1 > a[n - 1]:       # n - 1개 중 최댓값과 n - 1번 위치 값을 비교
        return max_n_1
    else:
        return a[n - 1]


v = [17, 92, 18, 33, 58, 7, 33, 42]
print(find_max(v, len(v)))  # 함수에 리스트의 자료 개수를 인자로 추가하여 호출


# --------------------------------------------------------------------

# 두 자연수 a,b의 최대공약수를 구하는 알고리즘★

def gcd(a, b):
    i = min(a, b)  # 두 수에 더 작은 수를 i에 저장
    while True:  # 최대공약수 i를 찾을 때 까지 반복
        if a % i == 0 and b % i == 0:  # a와 b가 둘다 i로 나눠떨어지면
            return i  # i는 최대공약수로 반환
        i -= 1  # 최대공약수가 아니라면 1씩 감소시켜 최대공약수 찾기


print(gcd(1, 5))
print(gcd(12, 6))

# --------------------------------------------------------------------

# 유클리드 알고리즘
# 유클리드는 최대공약수의 규칙을 발견한 사람,
# gcd(a,b)는 gcd(b, a%b)와 같음
# 어떤 수와 자기자신의 최대공약수는 자기자신이다. gcd(n, 0) == n

# 재귀함수를 이용 -
# 종료조건: a나 b가 0이 되는 것
# 재귀 호출 조건: gcd(b, a % b)


def uclide_gcd(a, b):
    print("gcd: ", a, b)  # 재귀함수 과정을 볼 수 있음
    if b == 0:  # 종료조건
        return a
    return uclide_gcd(b, a % b)


print(uclide_gcd(81, 27))


# --------------------------------------------------------------------

# 피보나치 수열 구하기 알고리즘
# n번째 피보나치 수열 찾기
# 입력: n 값(0부터 시작)
# 출력: n번째 피보나치 수열 값

def fib(n):
    if n <= 1:
        return n
    return fib(n-2) + fib(n-1)  # 피보나치 수열은 앞의 두개 수의 합이다


print(fib(10))


# --------------------------------------------------------------------

# 하노이의 탑

# 입력: 옮기려는 원반의 개수 n

#       옮길 원반이 현재 있는 출발점 기둥 from_pos

#       원반을 옮길 도착점 기둥 to_pos

#       옮기는 과정에서 사용할 보조 기둥 aux_pos

# 출력: 원반을 옮기는 순서


def hanoi(n, from_pos, to_pos, aux_pos):

    if n = = 1:  # 원반 한 개를 옮기는 문제면 그냥 옮기면 됨

        print(from_pos, ”->“, to_pos)

        return

    # 원반 n -1개를 aux_pos로 이동(to_pos를 보조 기둥으로)

    hanoi(n - 1, from_pos, aux_pos, to_pos)

    # 가장 큰 원반을 목적지로 이동

    print(from_pos, ”->“, to_pos)

    # aux_pos에 있는 원반 n -1개를 목적지로 이동(from_pos를 보조 기둥으로)

    hanoi(n - 1, aux_pos, to_pos, from_pos)


print(“n=1”)

hanoi(1, 1, 3, 2)  # 원반 한 개를 1번 기둥에서 3번 기둥으로 이동(2번을 보조 기둥으로)

print(“n=2”)

hanoi(2, 1, 3, 2)  # 원반 두 개를 1번 기둥에서 3번 기둥으로 이동(2번을 보조 기둥으로)

print(“n=3”)

hanoi(3, 1, 3, 2)  # 원반 세 개를 1번 기둥에서 3번 기둥으로 이동(2번을 보조 기둥으로)
