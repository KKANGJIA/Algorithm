# 그리디 알고리즘

## 지주 출제되는 문제

### 거스름돈 문제(with)
카운터에서 사용하는 동전은 500,100,50,10,원일 때 손님에게 거슬러줘야할 돈 N원일 때 거슬러줘야할 동전의 최소 개수를 구하시오 거슬러줘야할 돈 N은 항상 10의 배수이다

### 해결 아이디어: 최대금액의 동전부터 거슬러주고나서 나머지의 동전으로 거슬러주면된다
동전이 다들 배수이므로 최대 금액부터 거슬러줘도 최적의 해를 구할 수 잇는 것이다(최적의 해를 구할 수 있는 정당성)

### ex
n=1260원, 500 2개, 100 2개, 50 1개, 10 1개

### 코드
n = 1260
count = 0
array = [500,100,50,10]

for coin in array:
  count += n // coin # 해당 화폐를 거슬러 줄 수 있는 동전의 개수
  n %= coin

print(count)

시간의 복잡도 화폐의 개수로 금액과는 무관하며 동전의 종류에만 영향받음


### 1이 될때까지(스스로해결)
어떠한 수 N이 1이될때까지 두개의 과정 중 하나를 수행하여 결국에는 N이 1이되는 최적의 과정의 개수를 구하시오
1. N - 1
2. N // K


### 코드
n = 25 
k= 5
count = 0

while n > 1:
  if n % k == 0:
    n = n // k 
    count += 1
  elif  n % k != 0:
    n = n - 1
    count += 1

print(count)


### 곱하기 혹은 더하기(스스로해결)
각 자리 숫자가 0부터 9로만 이루어진 문자열 s가 주어졌을때,왼쪽부터 오른쪽으로 연산을 진행할때 가장 큰 수를 구하시오
하지만 일반계산 방식과는 달리 왼쪽에서부터 연산을 진행함
만들어질 수 있는 가장 큰 수는 20억 이하의 정수이다

### 해결 아이디어
0이 아닌 수라면 곱하기가 유리하고 0이라면 무조건 더해야함
* 내가 생각하지 못한 부분: 1이어도 곱하면 제자리 수니까 더하기가 더 유리함

### 코드
data = input() # 첫 번째 문자를 숫자로 변경하여 대입 
result = int(data[0]) 
for i in range(1, len(data)): # 두 수 중에서 하나라도 '0' 혹은 '1'인 경우, 곱하기보다는 더하기 수행 
  num = int(data[i]) 
  if num <= 1 or result <= 1: 
    result += num 
  else: 
    result *= num 
    
print(result)

### 모험가 길드 문제(with)
한 마을에 모험가 N명 , 모험가 대상으로 공포도를 측정했는데 높은 모험가는 쉽게 공포를 느끼므로 위험 상황에서 대처능력이 미미
모험가 장은 모험가 그룸을 공포도 X인 모험가를 반드시 X명 이상 포함해서 모험가 그룹을 만든다
이렇게 최대 몇개의 모험가 그룹을 만들 수 있는지 구해라
N명의 모험가가 주어졌을 때, 그룹의 최대수를 구하여라
(몇명의 모험가는 마을에 남아있어도 된다)

### 해결 아이디어
1, 2,2, 2,3

오름차순으로 정렬, ????????????????? 
각 수가 해당 수 이상의 개수면 제외 개수만큼 포함하는 거 부터 먼저 만들기
나머지 가지고 작은 수부터 처리?


### 코드
파일에서 확인하기


### 시간문제
정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하시오
문제조건: 2초 메모리제한: 128MB

### 해결 아이디어
나: N에서 3이상~23인 경우 3의 개수는 3개
00~59까지 3의 개수는 3,13,23,33,43,53 6개 
조합 라이브러리를 사용하여 개수를 구한다...가 아니라
0 13 13 / 0 13 13 / 0 12 13 / 0 13 12 순서가 중요한 순열 라이브러리가 필요(중복허용)

선생님: 가능한 모든 경우의 수를 세서 풀 수 있는 문제
모든 경우는 24*60*60 = 86,400가지 따라서 1씩 증가하면서 3이 포함되어있는 지 확인하면 된다

이러한 문제의 유형은 완전탐색(가능한 모든 경우의 수를 고려하는 brute force)이라고 부른다


### 코드 
n = int(input())
count = 0
for i in range(n + 1)"
  for j in range(60):
    for k in range(60):
    # 매 시각안에 3이 있으면 카운트 증가
    # 한줄의 문자열로 만들어서 3이 있는 지를 확인한다
    if '3' in str(i) + str(j) + str(k): 
      count += 1
      
print(count) # 11475


### 왕실의 나이트
왕실 정원은 체스판과 같이 8 X 8 좌표 평면이다 왕실 정원의 특정한 한 칸에 나이트가 서있다. 나이트는 말을 타고 있어 이돌할 때는 L자의 형태로만 이동이 가능하고 정원 밖으로는 나갈 수 없다. 나이트는 특정위치에서 다음과 같은 두가지 경우로만 이동이 가능하다.
1. 수평으로 두 칸 이동한 후에 수직으로 한 칸 이동하기
2. 수직으로 두 칸 이동한 후에 수평으로 한 칸 이동하기

이처럼 8 X 8 좌표평면 위에서 나이트의 위치가 주어졌을때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하라. 왕실의 정원에서 행의 위치를 표현할 때는 1부터 8로 표현하며, 열 위치를 표현할 때는 a부터 h로 표현한다

<img src="./images/왕실의 나이트.JPG" alt="왕실의 나이트 사진">

### 해결 아이디어
완전 탐색문제, 시뮬레이션, 구현 문제에 속하는 문제
나:갈 수 있는 곳 표시하고 조건으로 안되는 부분은 카운터 제외하기
(0,0) (7,7) => 총 8가지의 경우의 수 
x, y = 0
x += 2 y += 1  
x += 2 y -= 1  
x -= 2 y -= 1  
x -= 2 y += 1  

y += 2 x += 1  
y += 2 x -= 1  
y -= 2 x -= 1  
y -= 2 x += 1  

선생님: 


### 코드
답안 코드를 참고하기
비슷한 풀이이나 아스키 코드를 사용하는 것 반복문을 돌면서 방향벡터를 적용하는 것이 효율적인 코드임으로 이것을 참고하기


### <문자> 문자열 재정렬
알파벳 대문자와 숫자(0~9)로만 구성된 문자열이 입력으로 주어집니다. 이때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 그 뒤에 모든 숫자를 더한 값을 이어서 출력합니다.
예를 들어, K1KA5CB7이라는 값이 들어오면 ABCKK13을 출력합니다.

### 해결 아이디어
모든 문자열을 점검해서 isdigit으로 뺴내서 정렬 후 숫자만 빼서 모두 더해서 두개 붙여서 출력하기

### 코드
S = input() # K1KA5CB7

digit = ''
alpha = 0

for i in S:
  if i.isdigit():
    digit += i 




