# 그리디 알고리즘

## 지주 출제되는 문제

### 거스름돈 문제
카운터에서 사용하는 동전은 500,100,50,10,원일 때 손님에게 거슬러줘야할 돈 N원일 때 거슬러줘야할 동전의 최소 개수를 구하시오 거슬러줘야할 돈 N은 항상 10의 배수이다

### 해결 아이디어: 최대금액의 동전부터 거슬러주고나서 나머지의 동전으로 거슬러주면된다
동전이 다들 배수이므로 최대 금액부터 거슬러줘도 최적의 해를 구할 수 잇는 것이다(최적의 해를 구할 수 있는 정당성)

### ex
n=1260원, 500 2개, 100 2개, 50 1개, 10 1개

### 코드
n = 1260
count = 0
array = [500,100,50,10]

for coin in array:
  count += n // coin # 해당 화폐를 거슬러 줄 수 있는 동전의 개수
  n %= coin

print(count)

시간의 복잡도 화폐의 개수로 금액과는 무관하면 동전의 종류에만 영향받음


### 1이 될때까지
어떠한 수 N이 1이될때까지 두개의 과정 중 하나를 수행하여 결국에는 N이 1이되는 최적의 과정의 개수를 구하시오
1. N - 1
2. N // K


### 코드
n = 25 
k= 5
count = 0

while n > 1:
  if n % k == 0:
    n = n // k 
    count += 1
  elif  n % k != 0:
    n = n - 1
    count += 1

print(count)


### 곱하기 혹은 더하기
각 자리 숫자가 0부터 9로만 이루어진 문자열 s가 주어졌을때,왼쪽부터 오른쪽으로 연산을 진행할때 가장 큰 수를 구하시오
하지만 일반계산 방식과는 달리 왼쪽에서부터 연산을 진행함
만들어질 수 있는 가장 큰 수는 20억 이하의 정수이다

### 해결 아이디어
0이 아닌 수라면 곱하기가 유리하고 0이라면 무조건 더해야함
* 내가 생각하지 못한 부분: 1이어도 곱하면 제자리 수니까 더하기가 더 유리함

### 코드
data = input() # 첫 번째 문자를 숫자로 변경하여 대입 
result = int(data[0]) 
for i in range(1, len(data)): # 두 수 중에서 하나라도 '0' 혹은 '1'인 경우, 곱하기보다는 더하기 수행 
  num = int(data[i]) 
  if num <= 1 or result <= 1: 
    result += num 
  else: 
    result *= num 
    
print(result)

### 모험가 길드 문제
한 마을에 모험가 N명 , 모험가 대상으로 공포도를 측정했는데 높은 모험가는 쉽게 공포를 느끼므로 위험 상황에서 대처능력이 미미
모험가 장은 모험가 그룸을 공포도 X인 모험가를 반드시 X명 이상 포함해서 모험가 그룹을 만든다
이렇게 최대 몇개의 모험가 그룹을 만들 수 있는지 구해라
N명의 모험가가 주어졌을 때, 그룹의 최대수를 구하여라
(몇명의 모험가는 마을에 남아있어도 된다)






